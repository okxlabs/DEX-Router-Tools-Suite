{"version":3,"file":"static/js/359.79c2e070.chunk.js","mappings":"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","sources":["utils/masks.js","utils/validation.js","utils/dexrouter-abi.js","utils/formatters.js","utils/decode_functions.js"],"sourcesContent":["const { ethers } = require('ethers');\n\n/**\n * DexRouter Contract Masks\n * All the bitmasks used throughout the DexRouter contract for packed data\n */\n\n// Address mask (lower 160 bits)\nconst ADDRESS_MASK = ethers.BigNumber.from(\"0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\");\n\n// One for Zero mask (bit 255)\nconst ONE_FOR_ZERO_MASK = ethers.BigNumber.from(\"0x8000000000000000000000000000000000000000000000000000000000000000\");\n\n// WETH unwrap mask (bit 253)\nconst WETH_UNWRAP_MASK = ethers.BigNumber.from(\"0x2000000000000000000000000000000000000000000000000000000000000000\");\n\n// Order ID mask (bits 160-255)\nconst ORDER_ID_MASK = ethers.BigNumber.from(\"0xffffffffffffffffffffffff0000000000000000000000000000000000000000\");\n\n// Weight mask for rawData (bits 160-175)\nconst WEIGHT_MASK = ethers.BigNumber.from(\"0x00000000000000000000ffff0000000000000000000000000000000000000000\");\n\n// Reverse mask for rawData (bit 255)\nconst REVERSE_MASK = ethers.BigNumber.from(\"0x8000000000000000000000000000000000000000000000000000000000000000\");\n\n// Token tax masks for pools\nconst IS_TOKEN0_TAX_MASK = ethers.BigNumber.from(\"0x1000000000000000000000000000000000000000000000000000000000000000\");\nconst IS_TOKEN1_TAX_MASK = ethers.BigNumber.from(\"0x2000000000000000000000000000000000000000000000000000000000000000\");\n\n// WETH mask for pools (different from WETH_UNWRAP_MASK)\nconst WETH_MASK = ethers.BigNumber.from(\"0x4000000000000000000000000000000000000000000000000000000000000000\");\n\n// Numerator mask for pools (32-bit value at bits 160-191)\nconst NUMERATOR_MASK = ethers.BigNumber.from(\"0x0000000000000000ffffffff0000000000000000000000000000000000000000\");\n\n// Swap amount mask for swapWrap rawdata (all bits except the reverse bit)\nconst SWAP_AMOUNT_MASK = ethers.BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\n// DAG-specific masks for rawData in dagSwap functions\nconst DAG_INPUT_INDEX_MASK = ethers.BigNumber.from(\"0x0000000000000000ff0000000000000000000000000000000000000000000000\");\nconst DAG_OUTPUT_INDEX_MASK = ethers.BigNumber.from(\"0x000000000000000000ff00000000000000000000000000000000000000000000\");\n\nmodule.exports = {\n    ADDRESS_MASK,\n    ONE_FOR_ZERO_MASK,\n    WETH_UNWRAP_MASK,\n    ORDER_ID_MASK,\n    WEIGHT_MASK,\n    REVERSE_MASK,\n    IS_TOKEN0_TAX_MASK,\n    IS_TOKEN1_TAX_MASK,\n    WETH_MASK,\n    NUMERATOR_MASK,\n    SWAP_AMOUNT_MASK,\n    DAG_INPUT_INDEX_MASK,\n    DAG_OUTPUT_INDEX_MASK\n};\n","/**\n * Validation functions for checking parameter types and structures\n * Used for identifying specific data structures that need special formatting\n */\n\n/**\n * Check if the input represents a BaseRequest tuple\n * @param {Object} input - the function input definition from ABI\n * @param {any} value - the decoded value\n * @returns {boolean} true if this is a BaseRequest tuple\n */\nfunction isBaseRequestTuple(input, value) {\n    // Check if it's a tuple with the BaseRequest structure\n    return input.type === 'tuple' && \n           input.components && \n           input.components.length === 5 &&\n           input.components[0].type === 'uint256' &&\n           input.components[1].type === 'address' &&\n           input.components[2].type === 'uint256' &&\n           input.components[3].type === 'uint256' &&\n           input.components[4].type === 'uint256' &&\n           Array.isArray(value) && \n           value.length === 5;\n}\n\n/**\n * Check if the input represents a RouterPath array (batches parameter)\n * @param {Object} input - the function input definition from ABI\n * @param {any} value - the decoded value\n * @returns {boolean} true if this is a RouterPath array\n */\nfunction isRouterPathArray(input, value) {\n    // Check if it's a 2D array of RouterPath tuples (for batches)\n    // OR 1D array of RouterPath tuples (for DAG paths)\n    return (input.type === 'tuple[][]' || input.type === 'tuple[]') && \n           input.components && \n           input.components.length === 5 &&\n           input.components[0].type === 'address[]' &&\n           input.components[1].type === 'address[]' &&\n           input.components[2].type === 'uint256[]' &&\n           input.components[3].type === 'bytes[]' &&\n           input.components[4].type === 'uint256' &&\n           Array.isArray(value);\n}\n\n/**\n * Check if a single item is a RouterPath tuple\n * @param {any} item - the item to check\n * @returns {boolean} true if this is a RouterPath tuple\n */\nfunction isRouterPathTuple(item) {\n    return Array.isArray(item) && \n           item.length === 5;\n}\n\n/**\n * Check if the parameter is a packed receiver parameter\n * @param {Object} input - the function input definition from ABI\n * @param {string} paramName - the parameter name\n * @returns {boolean} true if this is a packed receiver parameter\n */\nfunction isPackedReceiver(input, paramName) {\n    // Check if it's a uint256 parameter named 'receiver'\n    return input.type === 'uint256' && paramName === 'receiver';\n}\n\n/**\n * Check if the parameter is a pools array\n * @param {Object} input - the function input definition from ABI\n * @param {string} paramName - the parameter name\n * @returns {boolean} true if this is a pools array parameter\n */\nfunction isPoolsArray(input, paramName) {\n    // Check if it's a uint256[] or bytes32[] parameter named 'pools'\n    return (input.type === 'uint256[]' || input.type === 'bytes32[]') && paramName === 'pools';\n}\n\n/**\n * Check if the parameter is a packed srcToken parameter\n * @param {Object} input - the function input definition from ABI\n * @param {string} paramName - the parameter name\n * @returns {boolean} true if this is a packed srcToken parameter\n */\nfunction isPackedSrcToken(input, paramName) {\n    // Check if it's a uint256 parameter named 'srcToken'\n    return input.type === 'uint256' && paramName === 'srcToken';\n}\n\n/**\n * Check if the parameter is a swapWrap rawdata parameter\n * @param {Object} input - the function input definition from ABI\n * @param {string} paramName - the parameter name\n * @returns {boolean} true if this is a swapWrap rawdata parameter\n */\nfunction isSwapWrapRawdata(input, paramName) {\n    // Check if it's a uint256 parameter named 'rawdata'\n    return input.type === 'uint256' && paramName === 'rawdata';\n}\n\nmodule.exports = {\n    isBaseRequestTuple,\n    isRouterPathArray,\n    isRouterPathTuple,\n    isPackedReceiver,\n    isPoolsArray,\n    isPackedSrcToken,\n    isSwapWrapRawdata\n};\n","const DEXROUTER_ABI = [\n    \"function smartSwapByOrderId(uint256 orderId, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, uint256[] batchesAmount, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[][] batches, tuple(uint256 fromToken, address toToken, address receiver, address payer, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine, uint256 orderId, bool isToB, bytes settlerData)[] extraData) external payable returns (uint256 returnAmount)\",\n    \"function unxswapByOrderId(uint256 srcToken, uint256 amount, uint256 minReturn, bytes32[] pools) external payable returns (uint256 returnAmount)\",\n    \"function smartSwapByInvest(tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, uint256[] batchesAmount, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[][] batches, tuple(uint256 fromToken, address toToken, address receiver, address payer, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine, uint256 orderId, bool isToB, bytes settlerData)[] extraData, address to) external payable returns (uint256 returnAmount)\",\n    \"function smartSwapByInvestWithRefund(tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, uint256[] batchesAmount, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[][] batches, tuple(uint256 fromToken, address toToken, address receiver, address payer, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine, uint256 orderId, bool isToB, bytes settlerData)[] extraData, address to, address refundTo) public payable returns (uint256 returnAmount)\",\n    \"function uniswapV3SwapTo(uint256 receiver, uint256 amount, uint256 minReturn, uint256[] pools) external payable returns (uint256 returnAmount)\",\n    \"function smartSwapTo(uint256 orderId, address receiver, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, uint256[] batchesAmount, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[][] batches, tuple(uint256 fromToken, address toToken, address receiver, address payer, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine, uint256 orderId, bool isToB, bytes settlerData)[] extraData) external payable returns (uint256 returnAmount)\",\n    \"function unxswapTo(uint256 srcToken, uint256 amount, uint256 minReturn, address receiver, bytes32[] pools) public payable returns (uint256 returnAmount)\",\n    \"function uniswapV3SwapToWithBaseRequest(uint256 orderId, address receiver, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, uint256[] pools) external payable returns (uint256 returnAmount)\",\n    \"function unxswapToWithBaseRequest(uint256 orderId, address receiver, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, bytes32[] pools) external payable returns (uint256 returnAmount)\",\n    \"function swapWrap(uint256 orderId, uint256 rawdata) external payable\",\n    \"function swapWrapToWithBaseRequest(uint256 orderId, address receiver, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest) external payable\",\n    \"function dagSwapByOrderId(uint256 orderId, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[] paths) external payable returns (uint256 returnAmount)\",\n    \"function dagSwapTo(uint256 orderId, address receiver, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[] paths) external payable returns (uint256 returnAmount)\",\n];\n\nmodule.exports = {\n    DEXROUTER_ABI\n};\n","const { ethers } = require('ethers');\nconst {\n    ADDRESS_MASK,\n    ONE_FOR_ZERO_MASK,\n    WETH_UNWRAP_MASK,\n    WEIGHT_MASK,\n    REVERSE_MASK,\n    IS_TOKEN0_TAX_MASK,\n    IS_TOKEN1_TAX_MASK,\n    WETH_MASK,\n    NUMERATOR_MASK,\n    SWAP_AMOUNT_MASK,\n    DAG_INPUT_INDEX_MASK,\n    DAG_OUTPUT_INDEX_MASK\n} = require('./masks');\nconst { isRouterPathTuple } = require('./validation');\n\n/**\n * Convert ethers BigNumbers to strings and process nested data structures\n * @param {any} value - the value to convert\n * @returns {any} converted value\n */\nfunction getValue(value) {\n    // Handle BigNumber objects\n    if (value && value._isBigNumber) {\n        const hexStr = value.toHexString();\n        \n        // If it looks like an address (20 bytes), convert to address format\n        if (hexStr.length === 42) { // 0x + 40 chars = 42 total\n            return hexStr;\n        }\n        \n        // For large numbers, return decimal string\n        return value.toString();\n    }\n    \n    // Handle arrays recursively\n    if (Array.isArray(value)) {\n        return value.map(item => getValue(item));\n    }\n    \n    // Handle objects recursively\n    if (value && typeof value === 'object' && value.constructor === Object) {\n        const cleaned = {};\n        for (const [key, val] of Object.entries(value)) {\n            cleaned[key] = getValue(val);\n        }\n        return cleaned;\n    }\n    \n    // Return primitive values as-is\n    return value;\n}\n\n/**\n * Format BaseRequest tuple with named fields\n * @param {Array} baseRequestArray - the BaseRequest tuple as array\n * @returns {Object} formatted BaseRequest with field names\n */\nfunction formatBaseRequest(baseRequestArray) {\n    const [fromToken, toToken, fromTokenAmount, minReturnAmount, deadLine] = baseRequestArray;\n    \n    return {\n        fromToken: getValue(fromToken),\n        toToken: getValue(toToken),\n        fromTokenAmount: getValue(fromTokenAmount),\n        minReturnAmount: getValue(minReturnAmount),\n        deadLine: getValue(deadLine)\n    };\n}\n\n/**\n * Format RouterPath array with named fields\n * @param {Array} routerPathArray - the 2D array of RouterPath tuples (or 1D for DAG)\n * @param {string} functionName - optional function name to determine decode type\n * @returns {Array} formatted RouterPath array with field names\n */\nfunction formatRouterPathArray(routerPathArray, functionName) {\n    // Check if this is a DAG function with 1D paths array\n    const isDagFunction = functionName && functionName.startsWith('dagSwap');\n    \n    if (isDagFunction) {\n        // DAG paths is a 1D array of RouterPath tuples\n        return routerPathArray.map(routerPath => {\n            if (isRouterPathTuple(routerPath)) {\n                return formatRouterPath(routerPath, functionName);\n            }\n            return getValue(routerPath);\n        });\n    } else {\n        // Regular 2D array for batch operations\n        return routerPathArray.map(batch => {\n            return batch.map(routerPath => {\n                if (isRouterPathTuple(routerPath)) {\n                    return formatRouterPath(routerPath, functionName);\n                }\n                return getValue(routerPath);\n            });\n        });\n    }\n}\n\n/**\n * Format a single RouterPath tuple with named fields\n * @param {Array} routerPathArray - the RouterPath tuple as array\n * @param {string} functionName - optional function name to determine decode type\n * @returns {Object} formatted RouterPath with field names\n */\nfunction formatRouterPath(routerPathArray, functionName) {\n    const [mixAdapters, assetTo, rawData, extraData, fromToken] = routerPathArray;\n    \n    return {\n        mixAdapters: getValue(mixAdapters),\n        assetTo: getValue(assetTo),\n        rawData: decodeRawDataArray(rawData, functionName),\n        extraData: getValue(extraData),\n        fromToken: getValue(fromToken)\n    };\n}\n\n/**\n * Decode rawData array by unpacking each uint256 value\n * @param {Array} rawDataArray - array of rawData uint256 values\n * @param {string} functionName - optional function name to determine decode type\n * @returns {Array} array of decoded rawData objects\n */\nfunction decodeRawDataArray(rawDataArray, functionName) {\n    if (!Array.isArray(rawDataArray)) {\n        return getValue(rawDataArray);\n    }\n    \n    // Check if this is from a DAG function\n    const isDagFunction = functionName && functionName.startsWith('dagSwap');\n    \n    return rawDataArray.map(rawDataItem => {\n        if (isDagFunction) {\n            return unpackDagRawData(rawDataItem);\n        } else {\n            return unpackRawData(rawDataItem);\n        }\n    });\n}\n\n/**\n * Unpack a single rawData uint256 value into its components\n * @param {any} rawDataValue - the rawData uint256 value (BigNumber or string)\n * @returns {Object} unpacked rawData with poolAddress, reverse, and weight\n */\nfunction unpackRawData(rawDataValue) {\n    try {\n        // Convert to BigNumber if it's not already\n        let rawDataBN;\n        if (rawDataValue && rawDataValue._isBigNumber) {\n            rawDataBN = rawDataValue;\n        } else {\n            rawDataBN = ethers.BigNumber.from(rawDataValue.toString());\n        }\n\n        // Extract components using bitwise operations\n        const poolAddress = rawDataBN.and(ADDRESS_MASK);\n        const reverseFlag = rawDataBN.and(REVERSE_MASK);\n        const weightMasked = rawDataBN.and(WEIGHT_MASK);\n        const weight = weightMasked.shr(160); // Shift right by 160 bits\n\n        return {\n            poolAddress: \"0x\" + poolAddress.toHexString().slice(2).padStart(40, '0'),\n            reverse: !reverseFlag.isZero(),\n            weight: weight.toString()\n        };\n    } catch (error) {\n        // If unpacking fails, return the original value\n        return {\n            original: getValue(rawDataValue),\n            error: `Failed to unpack rawData: ${error.message}`\n        };\n    }\n}\n\n/**\n * Unpack a receiver uint256 value into its components\n * @param {any} receiverValue - the receiver uint256 value (BigNumber or string)\n * @returns {Object} unpacked receiver with isOneForZero, isWethUnwrap, and address\n */\nfunction unpackReceiver(receiverValue) {\n    try {\n        // Convert to BigNumber if it's not already\n        let receiverBN;\n        if (receiverValue && receiverValue._isBigNumber) {\n            receiverBN = receiverValue;\n        } else {\n            receiverBN = ethers.BigNumber.from(receiverValue.toString());\n        }\n\n        // Extract components using bitwise operations\n        const isOneForZero = !receiverBN.and(ONE_FOR_ZERO_MASK).isZero();\n        const isWethUnwrap = !receiverBN.and(WETH_UNWRAP_MASK).isZero();\n        const address = receiverBN.and(ADDRESS_MASK);\n\n        return {\n            isOneForZero: isOneForZero,\n            isWethUnwrap: isWethUnwrap,\n            address: \"0x\" + address.toHexString().slice(2).padStart(40, '0')\n        };\n    } catch (error) {\n        // If unpacking fails, return the original value\n        return {\n            original: getValue(receiverValue),\n            error: `Failed to unpack receiver: ${error.message}`\n        };\n    }\n}\n\n/**\n * Unpack a pools array based on function type\n * @param {Array} poolsArray - the pools array (uint256[] or bytes32[])\n * @param {string} functionName - the name of the function being called\n * @returns {Array} unpacked pools array\n */\nfunction unpackPoolsArray(poolsArray, functionName) {\n    if (!Array.isArray(poolsArray) || poolsArray.length === 0) {\n        return getValue(poolsArray);\n    }\n\n    // Determine which type of pool unpacking to use based on function name\n    const isUnxswapFunction = functionName && functionName.startsWith('unxswap');\n\n    return poolsArray.map((poolValue, index) => {\n        // Convert bytes32 hex strings to BigNumber if needed\n        let processedPoolValue = poolValue;\n        if (typeof poolValue === 'string' && poolValue.startsWith('0x')) {\n            processedPoolValue = ethers.BigNumber.from(poolValue);\n        }\n\n        if (isUnxswapFunction) {\n            // unxswap functions: complex pool structure with all masks\n            return unpackUnxswapPool(processedPoolValue);\n        } else {\n            // uniswapV3 functions: simple pool structure with isOneForZero only\n            return unpackUniswapV3Pool(processedPoolValue);\n        }\n    });\n}\n\n/**\n * Unpack a single unxswap pool with all masks (isToken0Tax + isToken1Tax + WETH + numeratorMask value + address)\n * @param {any} poolValue - the pool uint256 value\n * @returns {Object} unpacked pool with boolean flags, numerator value, and address\n */\nfunction unpackUnxswapPool(poolValue) {\n    try {\n        // Convert to BigNumber if it's not already\n        let poolBN;\n        if (poolValue && poolValue._isBigNumber) {\n            poolBN = poolValue;\n        } else {\n            poolBN = ethers.BigNumber.from(poolValue.toString());\n        }\n\n        // Extract all components\n        const isToken0Tax = !poolBN.and(IS_TOKEN0_TAX_MASK).isZero();\n        const isToken1Tax = !poolBN.and(IS_TOKEN1_TAX_MASK).isZero();\n        const isWETH = !poolBN.and(WETH_MASK).isZero();\n        const numeratorValue = poolBN.and(NUMERATOR_MASK).shr(160);\n        const address = poolBN.and(ADDRESS_MASK);\n\n        return {\n            isToken0Tax: isToken0Tax,\n            isToken1Tax: isToken1Tax,\n            WETH: isWETH,\n            numerator: numeratorValue.toString(),\n            address: \"0x\" + address.toHexString().slice(2).padStart(40, '0')\n        };\n    } catch (error) {\n        return {\n            original: getValue(poolValue),\n            error: `Failed to unpack unxswap pool: ${error.message}`\n        };\n    }\n}\n\n/**\n * Unpack a single uniswapV3 pool with simple structure (isOneForZero + address)\n * @param {any} poolValue - the pool uint256 value\n * @returns {Object} unpacked pool with isOneForZero and address\n */\nfunction unpackUniswapV3Pool(poolValue) {\n    try {\n        // Convert to BigNumber if it's not already\n        let poolBN;\n        if (poolValue && poolValue._isBigNumber) {\n            poolBN = poolValue;\n        } else {\n            poolBN = ethers.BigNumber.from(poolValue.toString());\n        }\n\n        // Extract components\n        const isOneForZero = !poolBN.and(ONE_FOR_ZERO_MASK).isZero();\n        const address = poolBN.and(ADDRESS_MASK);\n\n        return {\n            isOneForZero: isOneForZero,\n            pool: \"0x\" + address.toHexString().slice(2).padStart(40, '0')\n        };\n    } catch (error) {\n        return {\n            original: getValue(poolValue),\n            error: `Failed to unpack uniswapV3 pool: ${error.message}`\n        };\n    }\n}\n\n/**\n * Unpack a srcToken uint256 value into its components\n * @param {any} srcTokenValue - the srcToken uint256 value (BigNumber or string)\n * @returns {Object} unpacked srcToken with orderId and address\n */\nfunction unpackSrcToken(srcTokenValue) {\n    try {\n        // Convert to BigNumber if it's not already\n        let srcTokenBN;\n        if (srcTokenValue && srcTokenValue._isBigNumber) {\n            srcTokenBN = srcTokenValue;\n        } else {\n            srcTokenBN = ethers.BigNumber.from(srcTokenValue.toString());\n        }\n\n        // Extract components\n        const address = srcTokenBN.and(ADDRESS_MASK);\n        const orderId = srcTokenBN.shr(160); // Shift right by 160 bits to get the orderId\n\n        return {\n            orderId: orderId.toString(),\n            address: \"0x\" + address.toHexString().slice(2).padStart(40, '0')\n        };\n    } catch (error) {\n        // If unpacking fails, return the original value\n        return {\n            original: getValue(srcTokenValue),\n            error: `Failed to unpack srcToken: ${error.message}`\n        };\n    }\n}\n\n/**\n * Unpack a swapWrap rawdata uint256 value into its components\n * @param {any} rawdataValue - the rawdata uint256 value (BigNumber or string)\n * @returns {Object} unpacked rawdata with reverse flag and amount\n */\nfunction unpackSwapRawdata(rawdataValue) {\n    try {\n        // Convert to BigNumber if it's not already\n        let rawdataBN;\n        if (rawdataValue && rawdataValue._isBigNumber) {\n            rawdataBN = rawdataValue;\n        } else {\n            rawdataBN = ethers.BigNumber.from(rawdataValue.toString());\n        }\n\n        // Extract components using bitwise operations\n        const reversed = !rawdataBN.and(REVERSE_MASK).isZero();\n        const amount = rawdataBN.and(SWAP_AMOUNT_MASK);\n\n        return {\n            reversed: reversed,\n            amount: amount.toString()\n        };\n    } catch (error) {\n        // If unpacking fails, return the original value\n        return {\n            original: getValue(rawdataValue),\n            error: `Failed to unpack swapWrap rawdata: ${error.message}`\n        };\n    }\n}\n\n/**\n * Unpack a DAG rawData uint256 value into its components\n * @param {any} rawDataValue - the rawData uint256 value (BigNumber or string)\n * @returns {Object} unpacked rawData with poolAddress, reverse, weight, inputIndex, and outputIndex\n */\nfunction unpackDagRawData(rawDataValue) {\n    try {\n        // Convert to BigNumber if it's not already\n        let rawDataBN;\n        if (rawDataValue && rawDataValue._isBigNumber) {\n            rawDataBN = rawDataValue;\n        } else {\n            rawDataBN = ethers.BigNumber.from(rawDataValue.toString());\n        }\n\n        // Extract components using bitwise operations according to DAG specification:\n        // poolAddress := and(rawData, _ADDRESS_MASK)\n        // reverse := and(rawData, _REVERSE_MASK)\n        // weight := shr(160, and(rawData, _WEIGHT_MASK))\n        // inputIndex := shr(184, and(rawData, _INPUT_INDEX_MASK))\n        // outputIndex := shr(176, and(rawData, _OUTPUT_INDEX_MASK))\n        \n        const poolAddress = rawDataBN.and(ADDRESS_MASK);\n        const reverseFlag = rawDataBN.and(REVERSE_MASK);\n        const weight = rawDataBN.and(WEIGHT_MASK).shr(160); // Shift right by 160 bits\n        const inputIndex = rawDataBN.and(DAG_INPUT_INDEX_MASK).shr(184); // Shift right by 184 bits\n        const outputIndex = rawDataBN.and(DAG_OUTPUT_INDEX_MASK).shr(176); // Shift right by 176 bits\n\n        return {\n            poolAddress: \"0x\" + poolAddress.toHexString().slice(2).padStart(40, '0'),\n            reverse: !reverseFlag.isZero(),\n            weight: weight.toString(),\n            inputIndex: inputIndex.toString(),\n            outputIndex: outputIndex.toString()\n        };\n    } catch (error) {\n        // If unpacking fails, return the original value\n        return {\n            original: getValue(rawDataValue),\n            error: `Failed to unpack DAG rawData: ${error.message}`\n        };\n    }\n}\n\nmodule.exports = {\n    getValue,\n    formatBaseRequest,\n    formatRouterPathArray,\n    formatRouterPath,\n    decodeRawDataArray,\n    unpackRawData,\n    unpackReceiver,\n    unpackPoolsArray,\n    unpackUnxswapPool,\n    unpackUniswapV3Pool,\n    unpackSrcToken,\n    unpackSwapRawdata,\n    unpackDagRawData\n};\n","const { ethers } = require('ethers');\nconst { DEXROUTER_ABI } = require('./dexrouter-abi');\nconst {\n    isBaseRequestTuple,\n    isRouterPathArray,\n    isPackedReceiver,\n    isPoolsArray,\n    isPackedSrcToken,\n    isSwapWrapRawdata\n} = require('./validation');\nconst {\n    getValue,\n    formatBaseRequest,\n    formatRouterPathArray,\n    unpackReceiver,\n    unpackPoolsArray,\n    unpackSrcToken,\n    unpackSwapRawdata\n} = require('./formatters');\n\n// Initialize interface and function selectors once\nconst contractInterface = new ethers.utils.Interface(DEXROUTER_ABI);\nconst functionSelectors = new Map();\n\n// Initialize the function selectors mapping\nObject.values(contractInterface.functions).forEach(fragment => {\n    const selector = contractInterface.getSighash(fragment);\n    functionSelectors.set(selector, fragment);\n});\n\n/**\n * Decode transaction calldata\n * @param {string} calldata - the input data of the transaction (0x prefixed hexadecimal string)\n * @returns {Object} the decoded result\n */\nfunction decodeFunctions(calldata) {\n    try {\n        // Validate the input\n        if (!calldata || typeof calldata !== 'string') {\n            return createErrorResult('Invalid calldata input');\n        }\n        \n        // Ensure the calldata starts with 0x\n        if (!calldata.startsWith('0x')) {\n            calldata = '0x' + calldata;\n        }\n        \n        // Check the length (at least needs the function selector)\n        if (calldata.length < 10) {\n            return createErrorResult('calldata length is too short');\n        }\n        \n        // Extract the function selector (first 4 bytes)\n        const selector = calldata.slice(0, 10);\n        const fragment = functionSelectors.get(selector);\n        \n        if (!fragment) {\n            return createErrorResult(`Unknown function selector: ${selector}`, {\n                selector\n            });\n        }\n        \n        // Decode the function parameters\n        const decodedParams = contractInterface.decodeFunctionData(fragment, calldata);\n        \n        // Format the result\n        return createSuccessResult(fragment, selector, decodedParams);\n        \n    } catch (error) {\n        return createErrorResult(`Decoding failed: ${error.message}`, {\n            originalError: error.message\n        });\n    }\n}\n\n/**\n * Create the success result\n * @param {Object} fragment - the function fragment\n * @param {string} selector - the function selector\n * @param {Array} decodedParams - the decoded parameters\n * @returns {Object} the formatted success result\n */\nfunction createSuccessResult(fragment, selector, decodedParams) {\n    const namedParameters = createNamedParameters(fragment.inputs, decodedParams, fragment);\n    \n    return {\n        function: {\n            name: fragment.name,\n            selector: selector\n        },\n        ...namedParameters  // Spread the parameters at the top level\n    };\n}\n\n/**\n * Create named parameters object from function inputs and decoded values\n * @param {Array} inputs - the function input definitions from ABI\n * @param {Array} decodedParams - the decoded parameter values\n * @param {Object} fragment - the function fragment for context\n * @returns {Object} object with parameter names as keys and values\n */\nfunction createNamedParameters(inputs, decodedParams, fragment) {\n    const namedParams = {};\n    \n    inputs.forEach((input, index) => {\n        // Use the parameter name from ABI, or create a default name\n        const paramName = input.name || `param${index}`;\n        let value = getValue(decodedParams[index]);\n        \n        // Special handling for BaseRequest tuple\n        if (isBaseRequestTuple(input, value)) {\n            value = formatBaseRequest(value);\n        }\n        // Special handling for RouterPath arrays (batches or DAG paths)\n        else if (isRouterPathArray(input, value)) {\n            value = formatRouterPathArray(value, fragment.name);\n        }\n        // Special handling for packed receiver parameter in uniswapV3SwapTo\n        else if (isPackedReceiver(input, paramName)) {\n            value = unpackReceiver(value);\n        }\n        // Special handling for pools array (different types for different functions)\n        else if (isPoolsArray(input, paramName)) {\n            value = unpackPoolsArray(value, fragment.name);\n        }\n        // Special handling for packed srcToken parameter in unxswapByOrderId\n        else if (isPackedSrcToken(input, paramName)) {\n            value = unpackSrcToken(value);\n        }\n        // Special handling for swapWrap rawdata parameter\n        else if (isSwapWrapRawdata(input, paramName)) {\n            value = unpackSwapRawdata(value);\n        }\n        \n        namedParams[paramName] = value;\n    });\n    \n    return namedParams;\n}\n\n/**\n * Create the error result\n * @param {string} message - the error message\n * @param {Object} extra - the extra information\n * @returns {Object} the error result\n */\nfunction createErrorResult(message, extra = {}) {\n    return {\n        error: message,\n        ...extra\n    };\n}\n\n// Export main functionality\nmodule.exports = {\n    decodeFunctions\n};\n"],"names":["ethers","require","ADDRESS_MASK","BigNumber","from","ONE_FOR_ZERO_MASK","WETH_UNWRAP_MASK","ORDER_ID_MASK","WEIGHT_MASK","REVERSE_MASK","IS_TOKEN0_TAX_MASK","IS_TOKEN1_TAX_MASK","WETH_MASK","NUMERATOR_MASK","SWAP_AMOUNT_MASK","DAG_INPUT_INDEX_MASK","DAG_OUTPUT_INDEX_MASK","module","exports","isBaseRequestTuple","input","value","type","components","length","Array","isArray","isRouterPathArray","isRouterPathTuple","item","isPackedReceiver","paramName","isPoolsArray","isPackedSrcToken","isSwapWrapRawdata","DEXROUTER_ABI","getValue","_isBigNumber","hexStr","toHexString","toString","map","constructor","Object","cleaned","key","val","entries","formatRouterPath","routerPathArray","functionName","mixAdapters","assetTo","rawData","extraData","fromToken","decodeRawDataArray","rawDataArray","isDagFunction","startsWith","rawDataItem","unpackDagRawData","unpackRawData","rawDataValue","rawDataBN","poolAddress","and","reverseFlag","weight","shr","slice","padStart","reverse","isZero","error","original","concat","message","unpackUnxswapPool","poolValue","poolBN","isToken0Tax","isToken1Tax","isWETH","numeratorValue","address","WETH","numerator","unpackUniswapV3Pool","isOneForZero","pool","inputIndex","outputIndex","formatBaseRequest","baseRequestArray","toToken","fromTokenAmount","minReturnAmount","deadLine","formatRouterPathArray","routerPath","batch","unpackReceiver","receiverValue","receiverBN","isWethUnwrap","unpackPoolsArray","poolsArray","isUnxswapFunction","index","processedPoolValue","unpackSrcToken","srcTokenValue","srcTokenBN","orderId","unpackSwapRawdata","rawdataValue","rawdataBN","reversed","amount","contractInterface","utils","Interface","functionSelectors","Map","createErrorResult","extra","arguments","undefined","_objectSpread","values","functions","forEach","fragment","selector","getSighash","set","decodeFunctions","calldata","get","decodedParams","namedParameters","inputs","namedParams","name","createNamedParameters","function","createSuccessResult","decodeFunctionData","originalError"],"sourceRoot":""}