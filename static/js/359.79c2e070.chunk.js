(self.webpackChunkevm_tool_suite=self.webpackChunkevm_tool_suite||[]).push([[359],{39:(t,e,n)=>{const{ethers:r}=n(571),a=r.BigNumber.from("0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff"),o=r.BigNumber.from("0x8000000000000000000000000000000000000000000000000000000000000000"),u=r.BigNumber.from("0x2000000000000000000000000000000000000000000000000000000000000000"),s=r.BigNumber.from("0xffffffffffffffffffffffff0000000000000000000000000000000000000000"),i=r.BigNumber.from("0x00000000000000000000ffff0000000000000000000000000000000000000000"),f=r.BigNumber.from("0x8000000000000000000000000000000000000000000000000000000000000000"),d=r.BigNumber.from("0x1000000000000000000000000000000000000000000000000000000000000000"),m=r.BigNumber.from("0x2000000000000000000000000000000000000000000000000000000000000000"),c=r.BigNumber.from("0x4000000000000000000000000000000000000000000000000000000000000000"),p=r.BigNumber.from("0x0000000000000000ffffffff0000000000000000000000000000000000000000"),l=r.BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),A=r.BigNumber.from("0x0000000000000000ff0000000000000000000000000000000000000000000000"),T=r.BigNumber.from("0x000000000000000000ff00000000000000000000000000000000000000000000");t.exports={ADDRESS_MASK:a,ONE_FOR_ZERO_MASK:o,WETH_UNWRAP_MASK:u,ORDER_ID_MASK:s,WEIGHT_MASK:i,REVERSE_MASK:f,IS_TOKEN0_TAX_MASK:d,IS_TOKEN1_TAX_MASK:m,WETH_MASK:c,NUMERATOR_MASK:p,SWAP_AMOUNT_MASK:l,DAG_INPUT_INDEX_MASK:A,DAG_OUTPUT_INDEX_MASK:T}},335:t=>{t.exports={isBaseRequestTuple:function(t,e){return"tuple"===t.type&&t.components&&5===t.components.length&&"uint256"===t.components[0].type&&"address"===t.components[1].type&&"uint256"===t.components[2].type&&"uint256"===t.components[3].type&&"uint256"===t.components[4].type&&Array.isArray(e)&&5===e.length},isRouterPathArray:function(t,e){return("tuple[][]"===t.type||"tuple[]"===t.type)&&t.components&&5===t.components.length&&"address[]"===t.components[0].type&&"address[]"===t.components[1].type&&"uint256[]"===t.components[2].type&&"bytes[]"===t.components[3].type&&"uint256"===t.components[4].type&&Array.isArray(e)},isRouterPathTuple:function(t){return Array.isArray(t)&&5===t.length},isPackedReceiver:function(t,e){return"uint256"===t.type&&"receiver"===e},isPoolsArray:function(t,e){return("uint256[]"===t.type||"bytes32[]"===t.type)&&"pools"===e},isPackedSrcToken:function(t,e){return"uint256"===t.type&&"srcToken"===e},isSwapWrapRawdata:function(t,e){return"uint256"===t.type&&"rawdata"===e}}},477:t=>{t.exports={DEXROUTER_ABI:["function smartSwapByOrderId(uint256 orderId, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, uint256[] batchesAmount, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[][] batches, tuple(uint256 fromToken, address toToken, address receiver, address payer, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine, uint256 orderId, bool isToB, bytes settlerData)[] extraData) external payable returns (uint256 returnAmount)","function unxswapByOrderId(uint256 srcToken, uint256 amount, uint256 minReturn, bytes32[] pools) external payable returns (uint256 returnAmount)","function smartSwapByInvest(tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, uint256[] batchesAmount, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[][] batches, tuple(uint256 fromToken, address toToken, address receiver, address payer, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine, uint256 orderId, bool isToB, bytes settlerData)[] extraData, address to) external payable returns (uint256 returnAmount)","function smartSwapByInvestWithRefund(tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, uint256[] batchesAmount, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[][] batches, tuple(uint256 fromToken, address toToken, address receiver, address payer, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine, uint256 orderId, bool isToB, bytes settlerData)[] extraData, address to, address refundTo) public payable returns (uint256 returnAmount)","function uniswapV3SwapTo(uint256 receiver, uint256 amount, uint256 minReturn, uint256[] pools) external payable returns (uint256 returnAmount)","function smartSwapTo(uint256 orderId, address receiver, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, uint256[] batchesAmount, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[][] batches, tuple(uint256 fromToken, address toToken, address receiver, address payer, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine, uint256 orderId, bool isToB, bytes settlerData)[] extraData) external payable returns (uint256 returnAmount)","function unxswapTo(uint256 srcToken, uint256 amount, uint256 minReturn, address receiver, bytes32[] pools) public payable returns (uint256 returnAmount)","function uniswapV3SwapToWithBaseRequest(uint256 orderId, address receiver, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, uint256[] pools) external payable returns (uint256 returnAmount)","function unxswapToWithBaseRequest(uint256 orderId, address receiver, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, bytes32[] pools) external payable returns (uint256 returnAmount)","function swapWrap(uint256 orderId, uint256 rawdata) external payable","function swapWrapToWithBaseRequest(uint256 orderId, address receiver, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest) external payable","function dagSwapByOrderId(uint256 orderId, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[] paths) external payable returns (uint256 returnAmount)","function dagSwapTo(uint256 orderId, address receiver, tuple(uint256 fromToken, address toToken, uint256 fromTokenAmount, uint256 minReturnAmount, uint256 deadLine) baseRequest, tuple(address[] mixAdapters, address[] assetTo, uint256[] rawData, bytes[] extraData, uint256 fromToken)[] paths) external payable returns (uint256 returnAmount)"]}},790:()=>{},807:(t,e,n)=>{const{ethers:r}=n(571),{ADDRESS_MASK:a,ONE_FOR_ZERO_MASK:o,WETH_UNWRAP_MASK:u,WEIGHT_MASK:s,REVERSE_MASK:i,IS_TOKEN0_TAX_MASK:f,IS_TOKEN1_TAX_MASK:d,WETH_MASK:m,NUMERATOR_MASK:c,SWAP_AMOUNT_MASK:p,DAG_INPUT_INDEX_MASK:l,DAG_OUTPUT_INDEX_MASK:A}=n(39),{isRouterPathTuple:T}=n(335);function g(t){if(t&&t._isBigNumber){const e=t.toHexString();return 42===e.length?e:t.toString()}if(Array.isArray(t))return t.map(t=>g(t));if(t&&"object"===typeof t&&t.constructor===Object){const e={};for(const[n,r]of Object.entries(t))e[n]=g(r);return e}return t}function k(t,e){const[n,r,a,o,u]=t;return{mixAdapters:g(n),assetTo:g(r),rawData:y(a,e),extraData:g(o),fromToken:g(u)}}function y(t,e){if(!Array.isArray(t))return g(t);const n=e&&e.startsWith("dagSwap");return t.map(t=>n?x(t):b(t))}function b(t){try{let e;e=t&&t._isBigNumber?t:r.BigNumber.from(t.toString());const n=e.and(a),o=e.and(i),u=e.and(s).shr(160);return{poolAddress:"0x"+n.toHexString().slice(2).padStart(40,"0"),reverse:!o.isZero(),weight:u.toString()}}catch(e){return{original:g(t),error:"Failed to unpack rawData: ".concat(e.message)}}}function S(t){try{let e;e=t&&t._isBigNumber?t:r.BigNumber.from(t.toString());const n=!e.and(f).isZero(),o=!e.and(d).isZero(),u=!e.and(m).isZero(),s=e.and(c).shr(160),i=e.and(a);return{isToken0Tax:n,isToken1Tax:o,WETH:u,numerator:s.toString(),address:"0x"+i.toHexString().slice(2).padStart(40,"0")}}catch(e){return{original:g(t),error:"Failed to unpack unxswap pool: ".concat(e.message)}}}function R(t){try{let e;e=t&&t._isBigNumber?t:r.BigNumber.from(t.toString());const n=!e.and(o).isZero();return{isOneForZero:n,pool:"0x"+e.and(a).toHexString().slice(2).padStart(40,"0")}}catch(e){return{original:g(t),error:"Failed to unpack uniswapV3 pool: ".concat(e.message)}}}function x(t){try{let e;e=t&&t._isBigNumber?t:r.BigNumber.from(t.toString());const n=e.and(a),o=e.and(i),u=e.and(s).shr(160),f=e.and(l).shr(184),d=e.and(A).shr(176);return{poolAddress:"0x"+n.toHexString().slice(2).padStart(40,"0"),reverse:!o.isZero(),weight:u.toString(),inputIndex:f.toString(),outputIndex:d.toString()}}catch(e){return{original:g(t),error:"Failed to unpack DAG rawData: ".concat(e.message)}}}t.exports={getValue:g,formatBaseRequest:function(t){const[e,n,r,a,o]=t;return{fromToken:g(e),toToken:g(n),fromTokenAmount:g(r),minReturnAmount:g(a),deadLine:g(o)}},formatRouterPathArray:function(t,e){return e&&e.startsWith("dagSwap")?t.map(t=>T(t)?k(t,e):g(t)):t.map(t=>t.map(t=>T(t)?k(t,e):g(t)))},formatRouterPath:k,decodeRawDataArray:y,unpackRawData:b,unpackReceiver:function(t){try{let e;e=t&&t._isBigNumber?t:r.BigNumber.from(t.toString());const n=!e.and(o).isZero(),s=!e.and(u).isZero();return{isOneForZero:n,isWethUnwrap:s,address:"0x"+e.and(a).toHexString().slice(2).padStart(40,"0")}}catch(e){return{original:g(t),error:"Failed to unpack receiver: ".concat(e.message)}}},unpackPoolsArray:function(t,e){if(!Array.isArray(t)||0===t.length)return g(t);const n=e&&e.startsWith("unxswap");return t.map((t,e)=>{let a=t;return"string"===typeof t&&t.startsWith("0x")&&(a=r.BigNumber.from(t)),n?S(a):R(a)})},unpackUnxswapPool:S,unpackUniswapV3Pool:R,unpackSrcToken:function(t){try{let e;e=t&&t._isBigNumber?t:r.BigNumber.from(t.toString());const n=e.and(a);return{orderId:e.shr(160).toString(),address:"0x"+n.toHexString().slice(2).padStart(40,"0")}}catch(e){return{original:g(t),error:"Failed to unpack srcToken: ".concat(e.message)}}},unpackSwapRawdata:function(t){try{let e;e=t&&t._isBigNumber?t:r.BigNumber.from(t.toString());const n=!e.and(i).isZero();return{reversed:n,amount:e.and(p).toString()}}catch(e){return{original:g(t),error:"Failed to unpack swapWrap rawdata: ".concat(e.message)}}},unpackDagRawData:x}},908:(t,e,n)=>{"use strict";n.r(e);var r=n(555);t=n.hmd(t);const{ethers:a}=n(571),{DEXROUTER_ABI:o}=n(477),{isBaseRequestTuple:u,isRouterPathArray:s,isPackedReceiver:i,isPoolsArray:f,isPackedSrcToken:d,isSwapWrapRawdata:m}=n(335),{getValue:c,formatBaseRequest:p,formatRouterPathArray:l,unpackReceiver:A,unpackPoolsArray:T,unpackSrcToken:g,unpackSwapRawdata:k}=n(807),y=new a.utils.Interface(o),b=new Map;function S(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(0,r.A)({error:t},e)}Object.values(y.functions).forEach(t=>{const e=y.getSighash(t);b.set(e,t)}),t.exports={decodeFunctions:function(t){try{if(!t||"string"!==typeof t)return S("Invalid calldata input");if(t.startsWith("0x")||(t="0x"+t),t.length<10)return S("calldata length is too short");const e=t.slice(0,10),n=b.get(e);if(!n)return S("Unknown function selector: ".concat(e),{selector:e});return function(t,e,n){const a=function(t,e,n){const r={};return t.forEach((t,a)=>{const o=t.name||"param".concat(a);let y=c(e[a]);u(t,y)?y=p(y):s(t,y)?y=l(y,n.name):i(t,o)?y=A(y):f(t,o)?y=T(y,n.name):d(t,o)?y=g(y):m(t,o)&&(y=k(y)),r[o]=y}),r}(t.inputs,n,t);return(0,r.A)({function:{name:t.name,selector:e}},a)}(n,e,y.decodeFunctionData(n,t))}catch(e){return S("Decoding failed: ".concat(e.message),{originalError:e.message})}}}}}]);
//# sourceMappingURL=359.79c2e070.chunk.js.map