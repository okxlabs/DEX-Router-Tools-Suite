{"version":3,"file":"static/js/744.14d66cea.chunk.js","mappings":"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","sources":["utils/decode_multi_trim.js"],"sourcesContent":["const { ethers } = require(\"ethers\");\n\n/**\n * Multi-Trim parsing script - used to parse ALL trim data from DEX transaction calldata\n * \n * This enhanced version can find multiple trims in a single calldata, unlike the original\n * decode_trim.js which stops after finding the first trim.\n * \n * Trim functionality allows distributing excess amounts proportionally to specified addresses\n * when transaction output exceeds the expected amount\n * \n * Data structure:\n * - Single Trim: 64 bytes (2 x 32-byte blocks)\n *   - First 32 bytes: trim_flag(6) + padding(6) + expect_amount(20)\n *   - Second 32 bytes: trim_flag(6) + trim_rate(6) + trim_address(20)\n * \n * - Dual Trim: 96 bytes (3 x 32-byte blocks)\n *   - First 32 bytes: trim_flag(6) + charge_rate(6) + charge_address(20)\n *   - Second 32 bytes: trim_flag(6) + padding(6) + expect_amount(20)\n *   - Third 32 bytes: trim_flag(6) + trim_rate(6) + trim_address(20)\n * \n * Usage example:\n * const allTrims = decodeMultipleTrimsFromCalldata(calldata);\n * console.log(\"All trims found:\", allTrims);\n */\n\n// Define trim flag constants (6 bytes)\nconst TRIM_FLAGS = {\n    SINGLE: \"0x777777771111\", // Single address trim flag\n    DUAL: \"0x777777772222\",   // Dual address trim flag\n};\n\n/**\n * Parse bytes32 to extract flag, rate, and address\n * @param {string} bytes32Hex - 32-byte hex string\n * @returns {object} - {flag, rate, address}\n */\nfunction parseTrimData(bytes32Hex) {\n    const hex = bytes32Hex.replace(/^0x/, \"\");\n    const flag = \"0x\" + hex.slice(0, 12); // 6 bytes\n    const rateHex = \"0x\" + hex.slice(12, 24); // 6 bytes\n    const rate = ethers.BigNumber.from(rateHex).toString();\n    const address = \"0x\" + hex.slice(24, 64); // 20 bytes\n    \n    // Validate flag must be in TRIM_FLAGS\n    const allValidFlags = [TRIM_FLAGS.SINGLE, TRIM_FLAGS.DUAL];\n    const isValidFlag = allValidFlags.some(validFlag => validFlag.toLowerCase() === flag.toLowerCase());\n    \n    if (!isValidFlag) {\n        throw new Error(`Invalid trim flag: ${flag}. Must be one of: ${allValidFlags.join(', ')}`);\n    }\n    \n    return { flag, rate, address };\n}\n\n/**\n * Parse expected amount from bytes32\n * @param {string} bytes32Hex - 32-byte hex string\n * @returns {string} - Expected amount as string\n */\nfunction parseExpectAmount(bytes32Hex) {\n    const hex = bytes32Hex.replace(/^0x/, \"\");\n    // Validate flag\n    const flag = \"0x\" + hex.slice(0, 12);\n    if (!Object.values(TRIM_FLAGS).some(f => f.toLowerCase() === flag.toLowerCase())) {\n        throw new Error(`Invalid trim flag in expect amount block: ${flag}`);\n    }\n    // Take low 20 bytes as expected amount\n    const expectAmountHex = \"0x\" + hex.slice(24, 64);\n    return ethers.BigNumber.from(expectAmountHex).toString();\n}\n\n/**\n * Find all occurrences of a pattern in calldata\n * @param {string} calldata - The calldata hex string\n * @param {string} pattern - The pattern to search for\n * @returns {number[]} - Array of positions where pattern is found\n */\nfunction findAllOccurrences(calldata, pattern) {\n    const positions = [];\n    let searchIndex = 0;\n    \n    while (true) {\n        const pos = calldata.indexOf(pattern, searchIndex);\n        if (pos === -1) break;\n        positions.push(pos);\n        searchIndex = pos + 1;\n    }\n    \n    return positions;\n}\n\n/**\n * Extract all single address trims from calldata\n * @param {string} calldataHex - The calldata hex string\n * @returns {object[]} - Array of single trim objects\n */\nfunction extractAllSingleTrims(calldataHex) {\n    const singleTrims = [];\n    const singleFlagHex = TRIM_FLAGS.SINGLE.replace(/^0x/, \"\");\n    const flagPositions = findAllOccurrences(calldataHex, singleFlagHex);\n    \n    // Group positions into pairs (each single trim needs 2 flag occurrences)\n    for (let i = 0; i < flagPositions.length - 1; i++) {\n        const firstFlagPos = flagPositions[i];\n        const secondFlagPos = flagPositions[i + 1];\n        \n        // Check if positions are 64 characters apart (32 bytes = 64 hex chars)\n        if (secondFlagPos - firstFlagPos === 64) {\n            try {\n                // First block: trim_flag + padding + expect_amount\n                const expectAmountBlock = \"0x\" + calldataHex.slice(firstFlagPos, firstFlagPos + 64);\n                // Second block: trim_flag + trim_rate + trim_address\n                const trimDataBlock = \"0x\" + calldataHex.slice(secondFlagPos, secondFlagPos + 64);\n                \n                // Parse expect amount from first block\n                const hex = expectAmountBlock.replace(/^0x/, \"\");\n                const expectAmountHex = \"0x\" + hex.slice(24, 64); // Take low 20 bytes\n                const expectAmountOut = ethers.BigNumber.from(expectAmountHex).toString();\n                \n                // Parse trim data from second block\n                const trimData = parseTrimData(trimDataBlock);\n                \n                singleTrims.push({\n                    type: \"single\",\n                    position: firstFlagPos,\n                    expectAmountOut: expectAmountOut,\n                    trimRate: trimData.rate,\n                    trimAddress: trimData.address\n                });\n                \n                // Skip the next position since we've used it\n                i++;\n            } catch (error) {\n                console.warn(`Failed to parse single trim at position ${firstFlagPos}:`, error.message);\n            }\n        }\n    }\n    \n    return singleTrims;\n}\n\n/**\n * Extract all dual address trims from calldata\n * @param {string} calldataHex - The calldata hex string\n * @returns {object[]} - Array of dual trim objects\n */\nfunction extractAllDualTrims(calldataHex) {\n    const dualTrims = [];\n    const dualFlagHex = TRIM_FLAGS.DUAL.replace(/^0x/, \"\");\n    const flagPositions = findAllOccurrences(calldataHex, dualFlagHex);\n    \n    // Group positions into triplets (each dual trim needs 3 flag occurrences)\n    for (let i = 0; i < flagPositions.length - 2; i++) {\n        const firstFlagPos = flagPositions[i];\n        const secondFlagPos = flagPositions[i + 1];\n        const thirdFlagPos = flagPositions[i + 2];\n        \n        // Check if positions are correctly spaced (64 chars apart each)\n        if (secondFlagPos - firstFlagPos === 64 && thirdFlagPos - secondFlagPos === 64) {\n            try {\n                // First block: trim_flag + charge_rate + charge_address\n                const chargeBlock = \"0x\" + calldataHex.slice(firstFlagPos, firstFlagPos + 64);\n                // Second block: trim_flag + padding + expect_amount\n                const expectAmountBlock = \"0x\" + calldataHex.slice(secondFlagPos, secondFlagPos + 64);\n                // Third block: trim_flag + trim_rate + trim_address\n                const trimDataBlock = \"0x\" + calldataHex.slice(thirdFlagPos, thirdFlagPos + 64);\n                \n                // Parse all three blocks\n                const chargeData = parseTrimData(chargeBlock);\n                const expectAmountOut = parseExpectAmount(expectAmountBlock);\n                const trimData = parseTrimData(trimDataBlock);\n                \n                dualTrims.push({\n                    type: \"dual\",\n                    position: firstFlagPos,\n                    expectAmountOut: expectAmountOut,\n                    trimRate: trimData.rate,\n                    trimAddress: trimData.address,\n                    chargeRate: chargeData.rate,\n                    chargeAddress: chargeData.address\n                });\n                \n                // Skip the next two positions since we've used them\n                i += 2;\n            } catch (error) {\n                console.warn(`Failed to parse dual trim at position ${firstFlagPos}:`, error.message);\n            }\n        }\n    }\n    \n    return dualTrims;\n}\n\n/**\n * Main function to extract all trims from calldata\n * @param {string} calldataHex - The calldata hex string\n * @returns {object} - Object containing all found trims and summary\n */\nfunction decodeMultipleTrimsFromCalldata(calldataHex) {\n    if (!calldataHex || typeof calldataHex !== 'string') {\n        throw new Error('Invalid calldata: must be a non-empty string');\n    }\n    \n    // Remove 0x prefix if present\n    const cleanCalldata = calldataHex.replace(/^0x/, \"\");\n    \n    // Extract all single and dual trims\n    const singleTrims = extractAllSingleTrims(cleanCalldata);\n    const dualTrims = extractAllDualTrims(cleanCalldata);\n    \n    // Combine and sort by position\n    const allTrims = [...singleTrims, ...dualTrims].sort((a, b) => a.position - b.position);\n    \n    return {\n        hasTrims: allTrims.length > 0,\n        totalTrims: allTrims.length,\n        allTrims: allTrims\n    };\n}\n\nmodule.exports = { \n    decodeMultipleTrimsFromCalldata,\n    TRIM_FLAGS\n};\n"],"names":["ethers","require","TRIM_FLAGS","SINGLE","DUAL","parseTrimData","bytes32Hex","hex","replace","flag","slice","rateHex","rate","BigNumber","from","toString","address","allValidFlags","some","validFlag","toLowerCase","Error","concat","join","parseExpectAmount","Object","values","f","expectAmountHex","findAllOccurrences","calldata","pattern","positions","searchIndex","pos","indexOf","push","module","exports","decodeMultipleTrimsFromCalldata","calldataHex","cleanCalldata","singleTrims","flagPositions","i","length","firstFlagPos","secondFlagPos","expectAmountBlock","trimDataBlock","expectAmountOut","trimData","type","position","trimRate","trimAddress","error","console","warn","message","extractAllSingleTrims","dualTrims","thirdFlagPos","chargeBlock","chargeData","chargeRate","chargeAddress","extractAllDualTrims","allTrims","sort","a","b","hasTrims","totalTrims"],"sourceRoot":""}