{"version":3,"file":"static/js/261.a12c04c2.chunk.js","mappings":"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","sources":["utils/decode_multi_commission.js"],"sourcesContent":["const { ethers } = require(\"ethers\");\n\n/**\n * Multi-occurrence decoder for commission and trim data\n * \n * This script handles cases where a single calldata contains multiple \n * commission and/or trim information blocks. It uses a recursive approach\n * to find all occurrences by searching from the end of each found occurrence.\n * \n * Usage:\n * const result = decodeMultipleFromCalldata(calldata);\n * console.log(JSON.stringify(result, null, 2));\n */\n\n// Define flag constants (6 bytes)\nconst COMMISSION_FLAGS = {\n    SINGLE: [ \n        \"0x3ca20afc2aaa\", // FROM_TOKEN_COMMISSION (high 6 bytes)\n        \"0x3ca20afc2bbb\", // TO_TOKEN_COMMISSION (high 6 bytes)\n    ],\n    DUAL: [ \n        \"0x22220afc2aaa\", // FROM_TOKEN_COMMISSION_DUAL (high 6 bytes)\n        \"0x22220afc2bbb\", // TO_TOKEN_COMMISSION_DUAL (high 6 bytes)\n    ]\n};\n\n\n// Parse bytes32 to {flag, rate, address}\nfunction parseCommission(bytes32Hex) {\n    const hex = bytes32Hex.replace(/^0x/, \"\");\n    const flag = \"0x\" + hex.slice(0, 12); // 6 bytes\n    const rateHex = \"0x\" + hex.slice(12, 24); // 6 bytes\n    const rate = ethers.BigNumber.from(rateHex).toString();\n    const address = \"0x\" + hex.slice(24, 64); // 20 bytes\n    \n    // Validate flag must be in COMMISSION_FLAGS\n    const allValidFlags = [...COMMISSION_FLAGS.SINGLE, ...COMMISSION_FLAGS.DUAL];\n    const isValidFlag = allValidFlags.some(validFlag => validFlag.toLowerCase() === flag.toLowerCase());\n    \n    if (!isValidFlag) {\n        throw new Error(`Invalid commission flag: ${flag}. Must be one of: ${allValidFlags.join(', ')}`);\n    }\n    \n    const commissionAmount = flag.startsWith(\"0x3ca2\") ? \"SINGLE\" : \"DUAL\";\n    const commissionToken = flag.endsWith(\"aaa\") ? \"FROM_TOKEN_COMMISSION\" : \"TO_TOKEN_COMMISSION\";\n    const commissionType = commissionAmount + \"_\" + commissionToken;\n    \n    return { \n        flag,\n        commissionType, \n        rate, \n        address\n    };\n}\n\n// Parse middle field for commission\nfunction parseMiddle(bytes32Hex) {\n    const hex = bytes32Hex.replace(/^0x/, \"\");\n    const isToB = hex.slice(0, 2) === \"80\";\n    const token = \"0x\" + hex.slice(24);\n    return { isToB, token };\n}\n\n\n/**\n * Recursively find all commission occurrences in calldata\n * @param {string} calldataHex - The calldata to search in\n * @param {number} startIndex - Index to start searching from\n * @returns {Array} Array of commission info objects\n */\nfunction findAllCommissions(calldataHex, startIndex = 0) {\n    const commissions = [];\n    let searchIndex = startIndex;\n    \n    while (searchIndex < calldataHex.length) {\n        let foundCommission = null;\n        let nextSearchIndex = calldataHex.length;\n        \n        // Handle SINGLE case\n        for (const singleFlag of COMMISSION_FLAGS.SINGLE) {\n            const flagHex = singleFlag.replace(/^0x/, \"\");\n            const flagIndex = calldataHex.indexOf(flagHex, searchIndex);\n            \n            if (flagIndex !== -1 && flagIndex < nextSearchIndex) {\n                const flagStart = flagIndex;\n                const flagEnd = flagStart + 64;\n                \n                if (flagStart >= 64) {\n                    try {\n                        const first = \"0x\" + calldataHex.slice(flagStart, flagEnd);\n                        const middle = \"0x\" + calldataHex.slice(flagStart - 64, flagStart);\n                        \n                        const firstCommission = parseCommission(first);\n                        const middleInfo = parseMiddle(middle);\n                        \n                        foundCommission = {\n                            hasCommission: true,\n                            referCount: 1,\n                            middle: middleInfo,\n                            first: firstCommission,\n                            position: flagStart\n                        };\n                        nextSearchIndex = flagEnd;\n                    } catch (error) {\n                        // Continue searching if parsing fails\n                    }\n                }\n            }\n        }\n        \n        // Handle DUAL case\n        for (const dualFlag of COMMISSION_FLAGS.DUAL) {\n            const flagHex = dualFlag.replace(/^0x/, \"\");\n            let firstIndex = calldataHex.indexOf(flagHex, searchIndex);\n            \n            if (firstIndex !== -1) {\n                let secondIndex = calldataHex.indexOf(flagHex, firstIndex + 1);\n                \n                if (secondIndex !== -1 && secondIndex < nextSearchIndex) {\n                    const flagStart = secondIndex;\n                    const flagEnd = flagStart + 64;\n                    \n                    if (flagStart >= 128) {\n                        try {\n                            const first = \"0x\" + calldataHex.slice(flagStart, flagEnd);\n                            const middle = \"0x\" + calldataHex.slice(flagStart - 64, flagStart);\n                            const last = \"0x\" + calldataHex.slice(flagStart - 128, flagStart - 64);\n                            \n                            const lastCommission = parseCommission(last);\n                            const firstCommission = parseCommission(first);\n                            const middleInfo = parseMiddle(middle);\n                            \n                            if (lastCommission.flag.toLowerCase() === dualFlag.toLowerCase()) {\n                                foundCommission = {\n                                    hasCommission: true,\n                                    referCount: 2,\n                                    hasToB: lastCommission.isToB || firstCommission.isToB || middleInfo.isToB,\n                                    last: lastCommission,\n                                    middle: middleInfo,\n                                    first: firstCommission,\n                                    position: flagStart\n                                };\n                                nextSearchIndex = flagEnd;\n                            }\n                        } catch (error) {\n                            // Continue searching if parsing fails\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (foundCommission) {\n            commissions.push(foundCommission);\n            searchIndex = nextSearchIndex;\n        } else {\n            break; // No more commissions found\n        }\n    }\n    \n    return commissions;\n}\n\n\n/**\n * Main function to decode multiple commission occurrences from calldata\n * @param {string} calldata - The transaction calldata to decode\n * @returns {Object} Object containing all found commission information\n */\nfunction decodeMultipleCommissionsFromCalldata(calldata) {\n    const calldataHex = calldata.replace(/^0x/, \"\").toLowerCase();\n    \n    // Find all commission occurrences\n    const commissions = findAllCommissions(calldataHex);\n    \n    // Format output as arrays\n    const result = {\n        totalCommissions: commissions.length,\n        commissionInfo: []\n    };\n    \n    // Add commission info as array\n    commissions.forEach((commission) => {\n        const commissionCopy = { ...commission };\n        commissionCopy.index = commissionCopy.position; // Keep position as index\n        delete commissionCopy.position; // Remove internal position tracking\n        result.commissionInfo.push(commissionCopy);\n    });\n    \n    return result;\n}\n\nmodule.exports = { \n    decodeMultipleCommissionsFromCalldata,\n    findAllCommissions\n};"],"names":["ethers","require","COMMISSION_FLAGS","SINGLE","DUAL","parseCommission","bytes32Hex","hex","replace","flag","slice","rateHex","rate","BigNumber","from","toString","address","allValidFlags","some","validFlag","toLowerCase","Error","concat","join","commissionAmount","startsWith","commissionToken","endsWith","commissionType","parseMiddle","isToB","token","findAllCommissions","calldataHex","commissions","searchIndex","arguments","length","undefined","foundCommission","nextSearchIndex","singleFlag","flagHex","flagIndex","indexOf","flagStart","flagEnd","first","middle","firstCommission","hasCommission","referCount","position","error","dualFlag","firstIndex","secondIndex","lastCommission","middleInfo","hasToB","last","push","module","exports","decodeMultipleCommissionsFromCalldata","calldata","result","totalCommissions","commissionInfo","forEach","commission","commissionCopy","_objectSpread","index"],"sourceRoot":""}